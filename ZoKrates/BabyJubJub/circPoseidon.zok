from "hashes/sha256/sha256Padded" import sha256Padded as sha;
from "ecc/babyjubjubParams" import BABYJUBJUB_PARAMS;
import "ecc/edwardsAdd" as add;
import "ecc/edwardsScalarMult" as mul;
import "ecc/edwardsOnCurve" as onCurve;
from "field" import FIELD_SIZE_IN_BITS;
import "utils/pack/bool/unpack";
from "utils/casts.zok" import cast;
import "utils/casts/u32_to_bits";
import "utils/pack/u32/pack256.zok";
import "hashes/poseidon/poseidon" as poseidon;

def main(field[2] X,field[2] R, field c ,field C, private field msgG,  private field alphaG ,  private field betaG , private field rhoG   )  {
      
    field[4] r = [msgG,alphaG,betaG,rhoG];
    assert( C== poseidon(r));

    field[2] G = [BABYJUBJUB_PARAMS.Gu, BABYJUBJUB_PARAMS.Gv];    
    bool[256] alpha = unpack(alphaG[0]);
    bool[256] beta = unpack(betaG[0]);   
    field[2] Rprime = add( add( mul(alpha, G, BABYJUBJUB_PARAMS), mul(beta, X, BABYJUBJUB_PARAMS), BABYJUBJUB_PARAMS), R, BABYJUBJUB_PARAMS);
    log("R' is {}", Rprime);

    bool[256] rprimeX = unpack(Rprime[0]);
    bool[256] xX = unpack(X[0]);    
    bool[256*3] hashValue = [...rprimeX,...xX,...msg];
    u32[8] h1 = sha(hashValue);
    field hb1 = pack256(h1);
    log("hash + beta {} ", hb1 + betaG[0]);
    assert(c == hb1 + betaG[0]);
    return ;
}